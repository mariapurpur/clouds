# Лабораторная работа №2 (со звёздочкой)  

## Рәхим итегез!  

  <img width="335" height="284" alt="image" src="https://github.com/user-attachments/assets/2017e91d-067b-40c5-9cad-bb69350b2ef0" />  

## Docker compose и practicies  

  Перед тем как начать разбираться в данной лабораторной работе, пожалуй, стоит уточнить, что изначально мы хотели делать лабораторную работу под номером 3*. Мы потратили на неё слишком много времени и сил, но ничего не работало, и мы сошлись на том, что выполнение данной лабораторной работы является лучшим вариантом для нас всех. Мы бы могли описать всю ту боль, которую испытали, в отдельном отчёте, но, думаем, количество раз, когда мы просили у вас ключ, уже показывает уровень отчаянности и отсутствия сил.  

  Что же, не будем о грустном. Перейдём к Docker compose.  

  Docker compose используется для упрощения процесса запуска контейнеров. То есть, если у нас есть какой-то "шаблон", которому мы хотим соответствовать с нашими docker контейнерами, то следует написать Docker compose и использовать одну команду вместо десятков одинаковых. В этой сфере есть как плохие, так и хорошие practicies.  

  **Плохие включают в себя:**  
> • Не указывать конкретные версии образов (может привести к некорректной работе);  
> • Явное указание переменных среды в самом файле (небезопасно, лучше писать в .env файл);  
> • Указание `ports` для всех контейнеров (небезопасно, лучше делать доступным наружу тот сервис, к которому нам надо подключиться, а все остальное оставить внутри сети проекта);  
> • Нет `volumes` (все данные просто потеряются при остановке контейнеров);  
> • И др.  

  Именно их мы будем избегать, а затем применять в выполнении задания.  
  
  Так как нам нужно добиться изоляции контейнеров в рамках compose-проекта, можно задаться вполне логичным вопросом "как"? Ответ прост: прописать разные сети в `networks` каждого из контейнеров. Принцип заключается в том, что мы просто разделяем эти сети для всех контейнеров, и не соединяем их одной.  
  
  Учитываем это и приступаем к работе!  

## Пишем плохой Docker compose

  После небольшого изучения того, как вообще выглядит синтаксис Docker compose, мы пришли к следующему виду плохого файла.  

```  
  services:
  db:  
    image: postgres  
    ports:
      - "5432:5432"  
    environment:  
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: SuperSecret123!
      POSTGRES_DB: production_db

  redis:  
    image: redis 
    ports:
      - "6379:6379" 
```  

  Как можно заметить, написанный файл собирает в себе кучу плохих practicies. Мало того, что мы не указываем конкретной версии, которую используем, так ещё и явно показываем, как нам всё равно на безопасность. Добиваем отсутствием `volumes` и указанием портов, и вот он — живой отвратительно идеальный Docker compose!  

  Запускаем всё это и проверим, как работает с помощью команды `docker-compose -f docker-compose.bad.yml up -d`.  

  <img width="1280" height="230" alt="image" src="https://github.com/user-attachments/assets/48437b9b-2866-4f57-ac20-0f41c06c0412" />  

  Проверим между ними пинг:  

  <img width="1192" height="441" alt="image" src="https://github.com/user-attachments/assets/ec802025-ca7d-44ea-aeb2-900db00bda8f" />  

  Видим, что они хоть и запустились, но видят друг друга, что не соответствует заданию, а тем более нашим ожиданиям. Мы разочарованы.  

## Пишем хороший Docker compose  

  Попробуем искупить наши грехи и попробовать написать по-настоящему годный файл. Выглядит он теперь так:  

```
  services:
  db:
    image: postgres:15-alpine  
    env_file: .env 
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - db_network 
  
  redis:  
    image: redis:7-alpine
    command: redis-server --appendonly yes 
    volumes:
      - redis_data:/data
    networks:
      - redis_network

volumes:
  postgres_data:
  redis_data:
networks:
  db_network:
    driver: bridge
  redis_network:
    driver: bridge
```

  Сразу видно, как на лице появляется улыбка! Согласитесь, так и хочется порадоваться от его вида. Тут и `volumes`, и указаны версии, и все секретные данные вынесены в отдельный .env файл.  

  Кстати, наш .env файл выглядит вот так:  
  
```
  POSTGRES_USER=admin
  POSTGRES_PASSWORD=secret123
  POSTGRES_DB=myapp
```

  Пробуем точно так же запустить, как делали это ранее:  
  
  <img width="1280" height="853" alt="image" src="https://github.com/user-attachments/assets/ea1467b2-300e-4eb6-8ac1-425c63a0eac2" />  

  Проверим пинг:  

  <img width="1240" height="220" alt="image" src="https://github.com/user-attachments/assets/fa0b20df-7a26-46dc-8e05-bd105f9c31c9" />  

  Как можно заметить, появилось больше networks, и если посмотреть, видят ли они все друг друга, обнаружим, что ответ отрицательный. Как итог, мы получили отличный рабочий файл, который можно использовать для дальнейшей работы!  

## Итоги

  Можно сделать вывод, что производительность и понятность точно улучшилась. В хорошем Docker compose мы получили разные docker-контейнеры с сервисами, которые независимы друг от друга, ведь используют разные сети, и получили приятный опыт. В плохом же, наоборот, всё зависит друг от друга, так ещё и отсутствует безопасность! Кошмар, так нельзя. Мы такое осуждаем.  

> Кроме того, хотелось бы заметить, что это одна из первых лабораторных работ, с которой мы не испытали практически никаких трудностей. Если честно, она нам показалась одной из самых простых в списке.
> Но это так, интересное замечание от нашей команды.  

## Перерыв на кошку  

  <img width="1080" height="604" alt="image" src="https://github.com/user-attachments/assets/ba539a42-1773-46d5-9277-051dabeea557" />  
